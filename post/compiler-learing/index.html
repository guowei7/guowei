<!DOCTYPE html>
<html
  dir="ltr"
  lang="zh-cn"
  data-theme=""
><head>
  <title>
    
      guowei
        |
        Compiler Learing


      


    
  </title>

  
  <meta charset="utf-8" /><meta name="generator" content="Hugo 0.68.3" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta
    name="description"
    content="
      软件定位能力培训


    "
  />
  
  
  
  <link
    rel="stylesheet"
    href="/guowei/css/main.min.b09acf2366fbe202ad032939e95c98c5225f27924653f3ca7b4988c169f1941c.css"
    integrity="sha256-sJrPI2b74gKtAyk56VyYxSJfJ5JGU/PKe0mIwWnxlBw="
    crossorigin="anonymous"
    type="text/css"
  />
  
  
  <link
    rel="stylesheet"
    href="/guowei/css/markupHighlight.min.8f07fad4abedfd5eb1396c6fef85ba7ec00ec867a79fb545c9db18df87f6760a.css"
    integrity="sha256-jwf61Kvt/V6xOWxv74W6fsAOyGenn7VFydsY34f2dgo="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"
    integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA=="
    crossorigin="anonymous"
  />
  
  <link rel="shortcut icon" href="/guowei/favicons/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" sizes="180x180" href="/guowei/favicons/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/guowei/favicons/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/guowei/favicons/favicon-16x16.png" />

  <link rel="canonical" href="http://guowei7.gitee.io/guowei/post/compiler-learing/" />

  
  
  
  
  <script
    type="text/javascript"
    src="/guowei/js/anatole-header.min.413f798d8aa82610bef17a5ca1d7e962ec185be395f1aeb3f45d1891af568b65.js"
    integrity="sha256-QT95jYqoJhC&#43;8XpcodfpYuwYW&#43;OV8a6z9F0Yka9Wi2U="
    crossorigin="anonymous"
  ></script>

  
    
    
    <script
      type="text/javascript"
      src="/guowei/js/anatole-theme-switcher.min.fcf9526f15b3b4e08472de192969ab28a4cdcb32ac94f83e85a8b84e9b45acd2.js"
      integrity="sha256-/PlSbxWztOCEct4ZKWmrKKTNyzKslPg&#43;hai4TptFrNI="
      crossorigin="anonymous"
    ></script>

  
  <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://guowei7.gitee.io/guowei/images/site-feature-image.png"/>

<meta name="twitter:title" content="Compiler Learing"/>
<meta name="twitter:description" content="软件定位能力培训"/>



  


  
  
  
  
  <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "articleSection": "post",
        "name": "Compiler Learing",
        "headline": "Compiler Learing",
        "alternativeHeadline": "",
        "description": "
      软件定位能力培训


    ",
        "inLanguage": "zh-cn",
        "isFamilyFriendly": "true",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/guowei7.gitee.io\/guowei\/post\/compiler-learing\/"
        },
        "author" : {
            "@type": "Person",
            "name": "guowei"
        },
        "creator" : {
            "@type": "Person",
            "name": "guowei"
        },
        "accountablePerson" : {
            "@type": "Person",
            "name": "guowei"
        },
        "copyrightHolder" : {
            "@type": "Person",
            "name": "guowei"
        },
        "copyrightYear" : "2021",
        "dateCreated": "2021-03-28T10:19:53.00Z",
        "datePublished": "2021-03-28T10:19:53.00Z",
        "dateModified": "2021-03-28T10:19:53.00Z",
        "publisher":{
            "@type":"Organization",
            "name": "guowei",
            "url": "http://guowei7.gitee.io/guowei",
            "logo": {
                "@type": "ImageObject",
                "url": "http:\/\/guowei7.gitee.io\/guowei\/favicons\/favicon-32x32.png",
                "width":"32",
                "height":"32"
            }
        },
        "image": 
      [
        
        "http://guowei7.gitee.io/guowei/images/site-feature-image.png"


      
      ]

    ,
        "url" : "http:\/\/guowei7.gitee.io\/guowei\/post\/compiler-learing\/",
        "wordCount" : "335",
        "genre" : [ 
      
      "C"

    ],
        "keywords" : [ 
      
      "debug"

    ]
    }
  </script>



</head>
<body>
    <header><div
  class="page-top 
    animated fadeInDown

  "
>
  <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
    <span aria-hidden="true"></span>
    <span aria-hidden="true"></span>
    <span aria-hidden="true"></span>
  </a>
  <nav>
    <ul class="nav__list" id="navMenu">
      <div class="nav__links">
        
        
          
          <li>
            <a
              
              href="/guowei/"
              
              title=""
              >Home</a
            >
          </li>

        
          
          <li>
            <a
              
              href="/guowei/post/"
              
              title=""
              >Post</a
            >
          </li>

        
      </div>
      <ul>
        
        
          <li>
            <a class="theme-switch" title="Switch Theme">
              <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a>
          </li>

        
      </ul>
    </ul>
  </nav>
</div>
</header>
    <div class="wrapper">
      <aside><div
  class="sidebar
    animated fadeInDown

  "
>
  <div class="sidebar__content">
    <div class="logo-title">
      <div class="title">
        <img src="/guowei/images/profile.jpg" alt="profile picture" />
        <h3 title=""><a href="/guowei">三体</a></h3>
        <div class="description">
          <p>给岁月以文明，而不是给文明以岁月。</p>
        </div>
      </div>
    </div>
    <ul class="social-links">
      
        <li>
          <a href="https://github.com/guowei7" rel="me" aria-label="GitHub" title="GitHub">
            <i class="fab fa-github fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
        <li>
          <a href="mailto:770857344@qq.com" rel="me" aria-label="e-mail" title="e-mail">
            <i class="fas fa-envelope fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
    </ul>
  </div><footer class="footer footer--sidebar">
  <div class="by_farbox">
    <ul class="footer__list">
      <li class="footer__item">
        &copy;
        
          guowei
          2022


        
      </li>
      
    </ul>
  </div>
</footer>
  
  <script
    type="text/javascript"
    src="/guowei/js/medium-zoom.min.bdc7b23aff63497a79433b3920b03e2473399d90ad4c2d87cf7c08d33d61966f.js"
    integrity="sha256-vceyOv9jSXp5Qzs5ILA&#43;JHM5nZCtTC2Hz3wI0z1hlm8="
    crossorigin="anonymous"
  ></script></div>
</aside>
      <main>
        <div class="autopagerize_page_element">
          <div class="content">
  <div
    class="post 
      animated fadeInDown

    "
  >
    <div class="post-content">
      
      <div class="post-title">
        <h1>Compiler Learing</h1>
        
          <div class="info">
            <em class="fas fa-calendar-day"></em>
            <span class="date"
              >
                Sun, Mar 28, 2021


              </span
            >
            <em class="fas fa-stopwatch"></em>
            <span class="reading-time">阅读时间 2 分钟</span>
          </div>

        
      </div><p>本文主要是针对编译调式等进行学习总结</p>
<h3 id="1-程序的编译链接">1. 程序的编译链接</h3>
<h4 id="程序的编译">程序的编译</h4>
<p>通过编译把文本形式源代码翻译为机器语言形式的目标文件，这个过程就是<em><strong>编译</strong></em>。<br>
将具有可读性的高级语言源代码，转变cpu可识别的机器码的工具，称为<em><strong>编译器</strong></em>。</p>
<ul>
<li>原生编译器：编译出的目标二进制基于与编译链所执行环境一致的根文件系统编译，并依赖该根文件系统的相关库执行，所使用的编译器称为原生编译器。</li>
<li>编译出的目标二进制，基于的根文件系统与工具链所执行的环境不一致的，所使用的编译器我们称为交叉编译器。</li>
</ul>
<p>编译是读取源程序(字符流)，对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码，源文件的编译过程包含两个主要阶段：<em><strong>编译预处理</strong></em>和<em><strong>编译</strong></em>。</p>
<ul>
<li>
<p>预编译</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">gcc -E proc.c -o proc.i 
<span style="color:#75715e">#对应的预处理命令cpp</span>
</code></pre></div><p>编译预处理读取源代码，对其中的伪指令(以#开头的指令)和特殊符号进行处理。宏展开，引用文件展开等动作均在这个过程中完成。文件编译过程中报错时，有些时候难以判断原因，可以使用预编译过程，将源代码文件展开成为预编译文件，观察错误是何原因。<br>
预编译程序所完成的基本上是对源代码的&quot;替代&quot;工作，经过此种替代，生成一个没有宏定义，没有条件编译指令，没有特殊符号的输出文件。这个文件的含义同没有经过预处理的源文件是相同的，但内容有所不同。<br>
经过预编译得到的输出文件中，只有常量；如  数字、字符串、变量的定义，以及C语言的关键字等等。</p>
</li>
<li>
<p>编译</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">gcc -S proc.i -o proc.s
<span style="color:#75715e">#对应的编译命令为cc</span>
</code></pre></div><p>编译程序所要做的工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则 之后，将其翻译成等价的中间代码表示或汇编代码。<br>
编译器对程序代码的编译主要分为下面几个过程：词法分析、语法分析、语义分析、中间代码生成、代码优化、代码生成、符号表管理、将多个步骤组合成躺、编译器构造工具。</p>
</li>
<li>
<p>汇编</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">gcc -c proc.s -o proc.o
<span style="color:#75715e">#对应的汇编命令是as</span>
</code></pre></div><p>汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被 翻译系统处理的每一个源代码，都将最终经过这一处理得到相应的目标文件，目标文件是为二进制文件，通常为.o。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。</p>
<ul>
<li>GCC有-g编译选项时，编译出的ELF(Executable and Linking Format)文件才包含的调试信息段。</li>
<li>可使用strip工具剥离调试信息段，剥离后的ELF文件依然可以正常运行。</li>
<li>可使用objcopy剥离调试信息段，独立保存为调试信息文件。</li>
<li>可使用objcopy将独立保存的调试信息文件与使用strip剥离出的可执行ELF文件部分&quot;链接&quot;起来</li>
</ul>
<p>使用objdump -t proc.o命令查看生成的符号表，目标文件由代码段、数据段、bss段、堆、栈组成。</p>
</li>
</ul>
<h4 id="程序的链接">程序的链接</h4>
<p>由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号(如变量或者函数调用等):在程序中可能调用了某个库文件中的函数等等。所有的这些问题，都需要经链接程序的处理方能得以解决。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">gcc -o  
<span style="color:#75715e">#链接的命令是ld</span>
</code></pre></div><p>程序的链接是将.o文件转化成可执行程序，使用的gcc命令是gcc -o，对应于链接命令是ld。程序的链接阶段可分为两个步骤：</p>
<ul>
<li>链接器首先将多个.o文件相应的段进行合并，建立映射关系并且去合并符号表。进行符号解析(符号解析的目的是让所有符号的引用找到该符号的定义),符号解析完成后就是给符号分配虚拟地址。</li>
<li>将分配好的虚拟地址与符号表中的定义的符号一一对应起来，使其成为正确的地址，使代码段的指令可以根据符号的地址执行相应的操作，最后由链接器生成可执行文件。</li>
</ul>
<p>链接处理可分为静态链接和动态链接两种：Linux下静态链接生成文件libXXX.a,动态链接生成文件libXXX.so。</p>
<ul>
<li>
<p>静态链接<br>
静态链接方式下，函数的代码将其从所在的静态链接库中被拷贝到最终的可执行程序中，这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。<br>
通常ar命令将.o文件打包成.a静态库，静态库是所有.o目标文件的一个集合。能够使用ar -t命令查看.a静态库包含了哪些目标文件。静态链接只是把.a静态库中需要的目标文件抽取出来参加链接，目标文件中的函数无论是否被调用都会被包含到新的可执行程序中去。</p>
<p>可以使用gcc和ar命令将lib.c和lib1.c编译链接生产lib.a静态库，并将proc.c使用 静态链接的方式生成了可执行程序proc_s，生成的文件大小733318Bytes。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">gcc -c lib1.c -o lib1.o -m32  
gcc -c lib.c -o lib.o -m32  
ar rcs -o lib.a lib1.o lib.o  
gcc -static -g -o proc_s proc.c lib.a -m32 
</code></pre></div><p>使用objdump -xD proc_s命令查看可执行程序，可执行程序包含了lib.c文件中colleagues_engineer和add1这两个函数，add1函数并没有被调用，由于连接器在链接静态库的时候以目标文件为单位，故add1函数还是被包含了进来。虽然lib1.c文件包含在lib.a静态库里面，但是由于lib1.c文件中的函数没有被调用，因此并没有包含lib1.c中的sub1函数。</p>
<ul>
<li>引用了静态库中的函数，那么链接器就会把库中包含这个函数的那个目标文件链接进来，如果很多函数都在一个目标文件中，很多没有用的函数会被一起链接进输出结果中。</li>
<li>在glibc的运行库libc.a有成百上千的函数，数量非常庞大，每个函数独立的放在一个目标文件库尽量的减少空间的浪费，那些 没有被用到的目标文件(函数)就不用链接到最初的 输出文件中。</li>
</ul>
<p>静态链接库代码装载速度快，执行速度略比动态链接库快；只需保证在开发者的计算机中有正确的lib库文件，在以二进制形式发布程序时不需考虑在用户的计算机上lib库是否存在及版本问题。但是静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费。<br>
可执行程序在不同的linux x86系统都可以正常执行。通过readelf -r prod_s命令查看，可执行文件没有符号需要加载，不需要依赖外部的文件。<br>
用gdb启动看执行程序，通过cat /proc/PID/maps 查看map分布情况，看到仅仅只加载了proc_s文件，没有任何glibc的库，从另一个侧面证明了静态链接是把函数的代码从其所在的静态链接库中拷贝到最终的可执行程序中。</p>
</li>
<li>
<p>动态链接<br>
动态链接方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息，在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间，动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。<br>
可以使用gcc命令将lib.c和lib1.c编译链接生成lib.so动态库，并将proc.c使用动态链接的方式生成了可执行程序proc_d，生成的文件大小8209Bytes。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">gcc -c lib1.c -o lib1.o -m32
gcc -c lib.c -o lib.o -m32
gcc -shared -fPIC -o lib.so lib1.o lib.o -m32
gcc -g -o proc_d proc.c ./lib.so -m32 
</code></pre></div><p>使用objdump -xD pros_s命令查看可执行程序，发现colleagues_engineer这个函数汇编跟objdump -d lib.o完全不一样。动态链接不会拷贝原函数，而是只是在可执行程序plt段中记录下共享对象的名字colleagues_engineer以及其它少量的登记信息，在程序执行的时候根据这些信息找到相应的代码函数。</p>
<p>相对于静态链接来说，动态链接有两个不同的地方：</p>
<ol>
<li>因为不允许对可执行文件的代码段进行加载时符号重定位，因此如果可执行文件引用了动态库中的数据符号，则在该可执行文件内对符号的重定位必须在链接阶段完成。为做到这一点，链接器在构建可执行文件的时候，会在当前可执行文件的数据段里分配出相应的空间来作为该符号真正的内存地址，等到运行时加载动态库后，再在动态库中对该符号的引用进行重定位；把对该符号的引用指向可执行文件数据段里相应的区域。</li>
<li>ELF文件对调用动态库中的函数采用了所谓的“延迟绑定”策略，只有当该函数在其第一次被调用发生时才最终被确认其真真正正的地址，因此我们不需要在调用动态库函数的地方直接填上假的地址，而是使用了一些跳转地址作为替换，这样一来连修改动态库和可执行程序中的相应代码都不需要进行了。</li>
</ol>
<p>动态链接库的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一些内存并减少页面交换，因为在内存中只需要保存一份此共享对象的代码；动态库文件与可执行文件独立，只要输出接口不变,更换动态库文件不会对可执行文件造成任何影响，因而极大地提高了可维护性和可扩展性；不同编程语言编写的程序只要按照函数调用约定就可以调用同一个动态库文件中的函数；适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和调试。<br>
但是动态链接库的应用程序不是自完备的，它以来的动态库文件也要存在，如果使用载入时动态链接，程序启动时发现动态库文件不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于动态库文件中的导出函数不可用，程序会加载失败；速度比静态链接慢。当某个模块更新后，如果新动态库与旧的动态库不兼容，那么那些需要该动态库才能运行的软件，都会启动失败。</p>
<p>可以使用ldd命令来查看可执行程序依赖库。ldd显示可执行模块的dependency的工作原理，其实质是通过ld-linux.so elf动态库的装载器来实现的。</p>
</li>
</ul>
<h3 id="2-程序的结构">2. 程序的结构</h3>
<h4 id="引言">引言</h4>
<p>定义两个源码<em><strong>全局变量</strong></em>一个初始化为1，一个初始化为0。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">int</span> g_global_var[<span style="color:#ae81ff">1024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>};
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">int</span> g_global_var[<span style="color:#ae81ff">1024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>第一个编译的大小为4M，而第二个则为4K。</p>
<h4 id="应用程序的构成">应用程序的构成</h4>
<p>进程(执行的应用程序)会占用一定数量的内存，它或是用来存放从磁盘载入的程序代码，或是存放取自用户输入的数据等等。不过进程对这些内存的管理方式因内存用途不一而不尽相同，有些内存是事先静态分配和统一回收的，而有些却是按需要动态分配和回收的。对任何一个普通的进程来说。会涉及5种不同的数据段：</p>
<ol>
<li>代码段(text segment/code segment)<br>
通常是指用来存放程序执行代码的一块区域，这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读，某些架构也允许代码段为可写，即允许修改程序，在代码段中，也有可能包含一些只读的常量变量，例如字符串常量等。</li>
<li>数据段(data segment)<br>
通常是指用来存放程序中** 已 **初始化的全局变量的一块内存区域，数据段属于静态内存分配。</li>
<li>bss段(bss segment)<br>
通常是指用来存放程序中** 未 **初始化的全局变量的一块内存区域，bss段属于静态内存分配。</li>
<li>堆(heap)<br>
用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时。新分配的内存就被动态添加到堆上(堆被扩张);当利用free等函数释放内存时，被释放的内存从堆中被删除(堆被缩减)。</li>
<li>栈<br>
用户存放程序临时创建的局部变量，也就是说我们函数中定义的变量(但不包括static声明的变量，static意味着在数据段中存放变量)。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且传到调用结束后，函数的返回值也会被存放回栈或者寄存器中。由于栈的先进后出特点，所以栈特别方便用来保存/恢复调用现场。它是由操作系统分配的。</li>
</ol>
<ul>
<li>全局的未初始化变量存在于bss段中，具体体现为一个占位符；全局的已初始化变量存于数据段中；而函数内的局部变量都在栈上分配空间。bss段是不占用应用程序文件空间的，编译器并不给该段的数据分配空间，只是记录数据所需空间的大小，其内容由操作系统初始化(清零)；而data却需要占用应用程序文件空间，其内容由程序初始化，数据保存在目标文件中，数据段包含经过初始化的全局变量以及它们的值。</li>
<li>bss段的大小从可执行文件中得到，然后连接器得到这个大小的内存块，紧跟在数据段后面，当这个内存区进入程序的地址空间后全部清零。包含数据段和bss段的整个区段此时通常称为数据区。</li>
</ul>
<p>Linux中不同类型的变量分布在不同的段中，在编译链接之后，会把不同的目标文件中定义的变量，按照类型合并到不同的段中。</p>
<p><img src="../../images/Compiler-Learning/c%E4%BB%A3%E7%A0%81%E5%92%8CELF%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB.png" alt="c代码和ELF映射关系"></p>
<h4 id="elf文件格式">ELF文件格式</h4>
<p>ELF文件是一种定义不同类型目标文件的文件格式，主要用于linux平台。可执行文件、可重定位文件(.o)、共享目标文件(.so)、核心转储文件都是以ELF文件格式存储的。<br>
ELF文件组成部分：文件头、程序头表、段表。文件开始处是一个ELF头部(ELF Header)，用来描述整个文件的组织结构。段表部分包含链接试图的大量信息：指令、数据、符号表、重定位信息等等。程序头表(Program Header Table)，如果存在的话，告诉系统如何创建进程映像。用来构造进程映像的目标文件必须具有程序头部表，可重定位文件不需要这个表。段表头部表(Section Header Table)包含了描述文件段表的信息，每个段表在段表头部表中都有一项，每一项给出诸如段表名称、段表大小这类信息。 文件头定义了ELF文件的整体信息，程序头表用来管理程序加载的信息，而段表用来管理每个段的信息。</p>
<ol>
<li>
<p>文件头<br>
文件最开始几个字节给出如何解释文件的提示信息。这些信息独立于处理器，也独立于文件中的其余内容。如：目标文件类型、目标文件的体系结构类型、目标文件版本等。</p>
</li>
<li>
<p>ELF文件段表<br>
一个应用程序至少包括代码段、数据段、bss段。ELF文件中除了这些段之外，还有其他的段。<br>
如和静态连接库以及动态连接库相关的段表rel、got、plt等。</p>
<ul>
<li>静态库<br>
在ELF文件信息中，各个静态库根据段的信息被合并到不同的段中。</li>
<li>动态库<br>
在静态链接时，整个程序被链接成为一个可执行文件，是一个不可分割的整体;但是在动态链接下，一个程序被分割成了若干文件，包括程序的主要部分，即可执行文件和程序所依赖的动态连接库，一个程序往往会依赖很多个动态库，程序加载动态库主要涉及ELF的rel段表和got段表。</li>
</ul>
</li>
<li>
<p>ELF文件程序头<br>
描述与程序执行直接相关的目标文件结构信息。用来在文件中定位各个段的映像。同时包含其他一些用来为程序创建进程映像所必需的信息。</p>
</li>
</ol>
<h4 id="elf相关命令">ELF相关命令</h4>
<ol>
<li>
<p>读取文件头<br>
通过命令<em><strong>readelf -h file</strong></em>可以读取文件头的内容。</p>
</li>
<li>
<p>读取文件段表头<br>
通过<em><strong>readelf -S file</strong></em>读取elf的段表，该命令可以读取段表数量以及每个段表大小；其中name为每个段表的名称，size一列为该段表大小，其中data段占用8字节，.bss段占用0x400020字节，但是.bss段不占用可执行程序的文件空间。</p>
</li>
<li>
<p>读取程序段表头<br>
通过<em><strong>readelf -I file</strong></em>读取elf文件的程序段表，其中type为程序段表类型，offset为elf文件的偏移量，virtAddr为内存地址偏移量。</p>
</li>
<li>
<p>nm导出符号表<br>
通过<em><strong>nm -S file</strong></em>命令导出符号表；在定位全局变量相关问题的时候，需要导出符号表以及查看符号表地址，可以使用<em><strong>nm -S file</strong></em>命令导出所有符号；其中第一列为全局变量地址，第二列为全局变量大小，第三列为全局变量类型，第四列为全局变量符号名称。</p>
</li>
<li>
<p>size查看ELF文件段信息 <br>
通过<em><strong>size file</strong></em>命令能够查看ELF文件中每个段的信息，其中text一列表示代码段大小，data一列表示数据段大小，bss一列表示bss段大小，dec表示总大小。</p>
</li>
<li>
<p>objdump查看反汇编信息<br>
通过objdump命令查看反汇编信息;在定位段错误 相关问题的时候，有的时候需要查看函数反汇编信息，可以使用<em><strong>objdump -S filename</strong></em>命令进行反汇编。</p>
</li>
<li>
<p>ldd命令查看elf文件依赖的库文件<br>
通过命令ldd查看进程依赖的动态库，当进程运行的时候，找不到依赖的动态库而终止运行的时候 ，可以通过该命令查看 该进程依赖的库文件，如果存在找不到库的情况，主要是依赖 的动态库没有安装到linux的lib相关路径，操作系统按照默认的系统路径找不到动态库。<br>
解决这种问题有两种方法：</p>
<ul>
<li>把依赖的动态库安装到操作系统默认的系统路径；</li>
<li>把动态库所在的路径添加到系统默认的路径中(/etc/ld.so.conf)，这样操作系统就能通过默认的系统路径找到需要的库文件了。</li>
</ul>
</li>
</ol>
<h3 id="3-程序的加载和销毁">3. 程序的加载和销毁</h3>
<h4 id="程序的加载">程序的加载</h4>
<pre><code>加载程序并不是把代码、数据、BSS段从可执行程序中填充到内存中，而是将它们的信息(基地址、长度等)更新到进程控制块(PCB)中，当CPU第一次实际寻址执行的时候，就会引起缺页中断，操作系统再将实际的内容从可执行文件中复制内容到物理内存中。程序加载的流程如下：  
&gt;fork创建进程-&gt;申请PCB-&gt;初始化PCB-&gt;进程分段分页-&gt;关联GDT-&gt;进程就绪状态-&gt;exec加载ELF  
</code></pre>
<ol>
<li>
<p>运行可执行程序<br>
在shell输入./可执行文件名后，调用fork函数开始创建新进程，产生int 0x80中断，调用sys_fork系统调用来创建进程。</p>
</li>
<li>
<p>申请PCB存储空间<br>
为了实现对进程的保护，系统为每个进程的管理专门设计了一个结构，即进程控制块(PCB)。内核通过申请一个页面用于保存进程控制块和内核栈，这个页面只能在内核的线性地址空间。</p>
</li>
<li>
<p>复制并初始化进程控制块<br>
为可执行程序复制了进程控制块后，新进程便继承了shell的全部管理信息。但每个进程控制块中的信息是不一样的，所以还要对该结构进行初始化设置，主要包括进程号、父进程、时间片、TSS段。</p>
</li>
<li>
<p>复制新进程页表并分段分页<br>
为进程分段(LDT)，更新代码段和数据段的基地址，即确定线性地址空间(关键在于确定段基址和限长)。接着就是分页，分页是建立在分段的基础上的。</p>
</li>
<li>
<p>关联新进程与全局描述符<br>
将新进程的TSS和LDT挂接在GDT的指定位置处。(TSS和LDT对进程的保护至关重要)。</p>
</li>
<li>
<p>设置新进程为就绪状态<br>
运行到这一部分，这个用户进程的管理结构就创建完毕了。</p>
</li>
<li>
<p>加载可执行文件<br>
程序的加载是通过执行exec系统掉调用实现的，当在命令行上执行一个可执行程序时最终都是通过这个系统掉采用来执行程序的。ELF文件加载在内核load_elf_binary函数实现主要步骤如下：</p>
<ul>
<li>检查目标程序ELF头部，比较文件头的前4个字节，查看是否为(&quot;\177ELF&rdquo;)，然后还需要确认该文件是可执行文件还是动态链接库文件，也就是代码中的ET_EXEC和ET_DYN。</li>
<li>检查加载目标程序的程序表头。首先检查该文件是否包含至少一个段，且所有段的大小之和是否超过64K。如果符合条件，调用kernel_read读入程序头表。</li>
<li>处理解释器(动态连接器)段。</li>
<li>检查并读取解释器的程序头表。加载解释器其实原理和加载ELF可执行程序一样，也是先检查解释器头部信息，然后加载解释器的程序头表，最后加载程序的段信息。</li>
<li>装入目标程序的段segment，即装入程序表头中的PT_LOAD的段。</li>
<li>填写程序的入口地址。前面的步骤已经完成了目标映像和解释器的加载，并且将目标程序的各个段加载进内存，一个程序成功执行，操作系统还需要知道程序的入口地址，才能开始执行加载好的映像。如果需要动态链接，就通过load_elf_interp装入解释器映像，并把将来进入用户空间的入口地址设置成load_elf_interp()的返回值，即解释器映像的入口地址。</li>
<li>填写目标文件的参数环境变量等必要信息，通过create_elf_tables，为目标映像和解释器准备一些有关的信息，包括argc、envc等，这些信息需要 复制到用户空间，使它们在CPU进入解释器或目标映像的程序入口时出现在用户空间堆栈上。</li>
<li>准备进入新的程序入口，将EIP和ESP改成新的地址，就使得CPU在返回用户空间时就进入新程序入口。如果存在动态库，那就是解释器的程序入口，否则就是目标程序入口。</li>
</ul>
</li>
<li>
<p>解释器完成动态链接</p>
<ul>
<li>解释器首先检查可执行程序所依赖的共享库，并在需要的时候对其进行加载。<br>
ELF文件有个特别的节区.dynamic，存放了和动态链接相关的很多信息，通过LD_LIBRARY_PATH参数可以找到动态链接库的绝对路径。通过/etc/ld.so.conf文件来指定。会用ldconfig工具创建一个库的缓存/etc/ld.so.cache。</li>
<li>解释器对程序的外部引用进行重定位，并告诉程序其引用的外部变量/函数地址，此地址位于共享库被加载在内存的区间内。动态链接还有一个延迟定位的特性，即只有在&quot;真正&quot;引用符号时才重定位。 
重定位的过程需要程序链表(plt)和全局偏移表(got)，plt属于代码段，got属于数据段。</li>
</ul>
</li>
<li>
<p>函数重定位过程</p>
<ul>
<li>首先call调用到对应的plt段，plt中jmp跳转处[a]存储的是下一条push指令，最后执行jmp跳转到plt[0]处，这是所有函数的重定位入口。</li>
<li>plt[0]首先执行push将got[1]中的link_map入栈，然后jmp跳转到got[2]的_dl_runtime_resolve函数获取引用函数的绝对地址，并将此地址写入[a]中。然后执行引用的函数。</li>
<li>这样地址[a]中就是要引用函数的绝对地址，当下一次执行时就直接跳转到函数的绝对地址了不需要再次重定位了。</li>
</ul>
<p>通过cat /proc/PID/maps查看map的分布情况。</p>
</li>
</ol>
<h4 id="程序的销毁">程序的销毁</h4>
<p>进程销毁可以通过几个事件驱动、通过正常的进程结束(当一个C程序从main函数返回时startup routine调用exit)、通过信号或是通过显式地对exit函数的调用。程序销毁的调用过程与程序加载执行的过程相反。</p>
<blockquote>
<p>main-&gt;exit-&gt;_fini-&gt;__libc_csu_fini-&gt;do_exit</p>
</blockquote>
<p>不管进程如何退出、进程的结束都要借助对内核do_exit的调用实现，主要完成下面几件事：</p>
<ul>
<li>清除所有信号处理函数。设置PF_EXITING标志来表明进程在退出，清除所有信息处理函数。</li>
<li>清除一系列的进程资源。如删除内存页、关闭所有打开的文件描述符，清理I/O缓存，如果缓存中有数据，会将它们写入相应的文件。清除当前目录关联的inode、清除线程信息等。</li>
<li>发出退出通知。调用exit_notify执行一系列通知。</li>
</ul>
<h4 id="僵尸进程产生原因">僵尸进程产生原因</h4>
<pre><code>父进程创建子进程时，如果调用了waitpid()等待子进程结束(表示它关心子进程的状态)，子进程结束时父进程会处理它发来的子进程退出信号(SIGCHLD)。如果不调用wait(表示它不关心子进程的状态)，则不会处理子进程退出信号(SIGCHLD)。如果父进程显式指定对子进程退出信号(SIGCHLD)处理为忽略(SIG_IGN)，或者标志为SA_NOCLDWAIT，这时在exit_notify中子进程马上变为EXIT_DEAD，表示我已退出并且死亡，最后被后面的release_task回收，将不会再有进程等待我。否则子进程变成EXIT_ZOMBIE，表示已退出但还没死。  
</code></pre>
<h4 id="僵尸进程的危害">僵尸进程的危害</h4>
<pre><code>进程退出时，内核释放该进程所有资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息(进程号、退出状态、运行时间等)，直到父进程通过wait/waitpid来取时才释放。  
如果不调用wait/waitpid的话，那么保留的信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。  
</code></pre>
<h4 id="如何处理僵尸进程">如何处理僵尸进程</h4>
<pre><code>僵尸进程产生是因为父进程没有wait子进程，所以写程序一定要在父进程中通过wait来避免僵尸进程的产生。  
当系统中出现了僵尸进程时，我们无法通过kill命令把它清除，但是可以杀死它的父进程，让它变成孤儿进程，并进一步被系统中管理孤儿进程的进程收养并清理。  
</code></pre>
<h3 id="3-cpu架构">3. CPU架构</h3>
<p>CPU架构是CPU厂商给属于同一系列的CPU产品定的一个规范，是区分不同类型CPU的重要标识。目前主要分为两类：一个是Intel、AMD(X86架构)为主的复杂指令集CPU，另一个是以IBM(PowerPC架构)、ARM(ARM架构)为主的精简指令集CPU。<br>
主流的cpu处理器都采用了冯诺伊曼架构或者哈佛架构，是控制数据和代码存储的架构;而x86和arm架构是指cpu控制指令的集合，每一个指令代表cpu内部设计的一个硬件电路实现。</p>
<ul>
<li>
<p>哈佛架构<br>
哈佛结构是一种将程序指令存储和数据存储分开的存储器结构。中央处理器先读取程序指令获取数据地址，再读取数据，并进行下一步的操作。程序指令存储和数据存储分开，可以使指令和数据有不同的数据宽度。有较高的执行效率，执行时可以预先读取下一条指令。</p>
</li>
<li>
<p>冯诺伊曼架构<br>
也称普林斯顿结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置，因此程序指令和数据的宽度相同。</p>
</li>
</ul>
<ul>
<li>
<p>CISC复杂指令集<br>
CISC(Complex Instruction Set Computing)。在CISC微处理器中，程序的各条指令是按顺序串行执行的，顺序执行的优点是控制简单，但计算机各部分的利用率不高，执行速度慢。</p>
</li>
<li>
<p>RISC精简指令集<br>
RISC(Reduced Instruction Set Computing)。</p>
</li>
</ul>
<h4 id="cpu架构是什么">CPU架构是什么</h4>
<h4 id="x86架构">x86架构</h4>
<h4 id="arm架构">ARM架构</h4>
<h4 id="linux系统cpu错误">Linux系统CPU错误</h4></div>
    <div class="post-footer">
      <div class="info">
        
          <span class="separator"><a class="category" href="/guowei/categories/c/">C</a></span>




        

        
          <span class="separator"><a class="tag" href="/guowei/tags/debug/">debug</a></span>




        
      </div>
    </div>

    
  </div>


          </div>
        </div>
      </main>
    </div><footer class="footer footer--base">
  <div class="by_farbox">
    <ul class="footer__list">
      <li class="footer__item">
        &copy;
        
          guowei
          2022


        
      </li>
      
    </ul>
  </div>
</footer>
  
  <script
    type="text/javascript"
    src="/guowei/js/medium-zoom.min.bdc7b23aff63497a79433b3920b03e2473399d90ad4c2d87cf7c08d33d61966f.js"
    integrity="sha256-vceyOv9jSXp5Qzs5ILA&#43;JHM5nZCtTC2Hz3wI0z1hlm8="
    crossorigin="anonymous"
  ></script></body>
</html>
