<!DOCTYPE html>
<html lang="zh-cn" data-theme=""><head>
    <title> guowei | C Learning Two </title>

    
    <meta charset="utf-8"><meta name="generator" content="Hugo 0.74.3" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
    <meta name="description" content="希望是本无所谓有，无所谓无的。这正如地上的路，其实地上本没有路；做的人多了，也便成了路。">
    
    <link rel="stylesheet"
          href="http://guowei7.gitee.io/guowei/css/style.min.fd8782302bada081c87839b0babafdcb62d89c344275ef480382a6471d4b9f8f.css"
          integrity="sha256-/YeCMCutoIHIeDmwurr9y2LYnDRCde9IA4KmRx1Ln48="
          crossorigin="anonymous"
          type="text/css">
    
    <link rel="stylesheet"
        href="http://guowei7.gitee.io/guowei/css/markupHighlight.min.9755453ffb7bc4cd220f86ebb5922107b49f193cc62fc17e9785d27b33a8bf5b.css"
        integrity="sha256-l1VFP/t7xM0iD4brtZIhB7SfGTzGL8F&#43;l4XSezOov1s="
        crossorigin="anonymous"
        type="text/css">
    
    <link rel="stylesheet" 
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" 
    integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" 
    crossorigin="anonymous" />

    
    <link rel="shortcut icon" href="http://guowei7.gitee.io/guowei/favicons/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="180x180" href="http://guowei7.gitee.io/guowei/favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="http://guowei7.gitee.io/guowei/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="http://guowei7.gitee.io/guowei/favicons/favicon-16x16.png">

    <link rel="canonical" href="http://guowei7.gitee.io/guowei/post/c-learning-two/">

    
    
    
    
    <script type="text/javascript"
            src="http://guowei7.gitee.io/guowei/js/anatole-header.min.d8599ee07b7d3f11bafbac30657ccc591e8d7fd36a9f580cd4c09e24e0e4a971.js"
            integrity="sha256-2Fme4Ht9PxG6&#43;6wwZXzMWR6Nf9Nqn1gM1MCeJODkqXE="
            crossorigin="anonymous"></script>


    
        
        
        <script type="text/javascript"
                src="http://guowei7.gitee.io/guowei/js/anatole-theme-switcher.min.e289e9ebb2a4e7a7f895859c8a2b0da2de1ec73f22cea58d8475aa0597023837.js"
                integrity="sha256-4onp67Kk56f4lYWciisNot4exz8izqWNhHWqBZcCODc="
                crossorigin="anonymous"></script>
    
    <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://guowei7.gitee.io/guowei/images/site-feature-image.png"/>

<meta name="twitter:title" content="C Learning Two"/>
<meta name="twitter:description" content="C primer Plus继续学习"/>

</head>
<body><div class="sidebar animated fadeInDown ">
    <div class="logo-title">
        <div class="title">
            <img src="http://guowei7.gitee.io/guowei/images/profile.jpg" alt="profile picture">
            <h3 title=""><a href="/">故乡</a></h3>
            <div class="description">
                <p>希望是本无所谓有，无所谓无的。这正如地上的路，其实地上本没有路；做的人多了，也便成了路。</p>
            </div>
        </div>
    </div>
    <ul class="social-links">
        
            <li>
                <a href="https://github.com/guowei7" rel="me" aria-label="GitHub">
                    <i class="fab fa-github fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="mailto:770857344@qq.com" rel="me" aria-label="e-mail">
                    <i class="fas fa-envelope fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
    </ul>
    <div class="footer">
        <div class="by_farbox">&copy; guowei  2021 </div>
    </div>
</div>
<div class="main">
    <div class="page-top  animated fadeInDown ">
    <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
    </a>
    <ul class="nav" id="navMenu">
        
        
            
            <li><a 
                   href="/guowei/"
                        
                   title="">Home</a></li>
        
            
            <li><a 
                   href="/guowei/post/"
                        
                   title="">Post</a></li>
        
        
        
            <li class="theme-switch-item">
                <a class="theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
            </li>
        
    </ul>
</div>

    <div class="autopagerize_page_element">
        <div class="content">
    <div class="post  animated fadeInDown ">
        <div class="post-content">
            
            <div class="post-title">
                <h3>C Learning Two</h3>
                
                    <div class="info">
                        <em class="fas fa-calendar-day"></em>
                        <span class="date"> Sat, Dec 12, 2020 
                                           </span>
                        <em class="fas fa-stopwatch"></em>
                        <span class="reading-time">阅读时间 4 分钟</span>
                    </div>
                
            </div>

            <p>由于C-Learning.md存在损坏，故重开一篇继续记录</p>
<h3 id="7-c控制语句分支和跳转">7. C控制语句：分支和跳转</h3>
<p>本章介绍以下内容：<br>
关键字：if、else、switch、continue、break、case、default、goto<br>
运算符：&amp;&amp;、||、？ ：<br>
函数：getchar()、putchar()、ctype.h系列<br>
如何使用if和if else语句，如何嵌套它们<br>
在更复杂的测试表达式中用逻辑运算符组合关系表达式<br>
C的条件运算符<br>
switch语句<br>
break、continue和goto语句 <br>
使用C的字符I/O函数：getchar()和puchar()<br>
ctype.h头文件提供的字符分析函数系列</p>
<h4 id="if语句">if语句</h4>
<p>下面的程序是读取一系列数据，每个数据都表示每日的最低问题，然后打印统计的总天数和最低温度在0°以下的天数占总天数的百分比。程序中的循环通过scanf()读入温度值。while循环每迭代一次，就递增计数器增加天数，其中的if语句负责判断0°以下的温度并单独统计相应的天数。<br>
<a href="../../c-example/colddays.c">colddays.c</a><br>
为避免整数除法，该程序示例把计算后的百分比强制转换为float类型。其实，也不必使用强制类型转换，因为在表达式100.0  * cold_dyas / all_days中，将首先对表达式100.0 * cold_days求值，由于C的自动转换类型规则，乘积会被强制转换成浮点数。但是，使用强制类型转换可以明确表达式转换类型的意图，保护程序免受不同版本编译器的影响。if语句被称为分支语句(branching statement)或选择语句(selection statement)，因为它相当于一个交叉点，程序要在两条分支中选择一条执行。if语句的通用形式如下：</p>
<blockquote>
<p>if(expression)<br>
statement</p>
</blockquote>
<p>如果对expression求值为真(非0),则执行statement：否则，跳过statement。与while循环一样，statement可以是一条简单语句或复合语句。if语句的结构和while语句很相似，它们的主要区别是：如果满足条件执行的话，if语句 只能测试和执行一次，而while语句可以测试和执行多次。<br>
通常，expression是关系表达式，即比较两个量的大小(如，表达式x &gt; y或c == 6)。如果expression为真(即x大于y，或c == 6),则执行statement。否则，忽略statement。概括地说，可以使用任意表达式，表达式的值为0则为假。<br>
statement部分可以是一条简单语句，如本例所示，或者是一条用花括号括起来的复合语句(或块)<br>
注意，即使if语句由复合语句构成，整个if语句仍被视为一条语句。</p>
<h4 id="if-else语句">if else语句</h4>
<p>简单形式的if语句可以让程序选择执行一条语句，或者跳过这条语句。C还提供了if else形式，可以在两条语句之间作选择。<br>
注意，if else语句的通用形式是：</p>
<blockquote>
<p>if(expression)
statement1
else
statement2</p>
</blockquote>
<p>如果expression为真(非0),则执行statement1；如果expression为假或0，则执行else后面的statement2。statement1和statement2可以是一条简单语句或复合语句。C并不要求一定要缩进，但这是标准风格。缩进让根据测试条件的求值结果来判断执行哪部分语句一目了然。<br>
如果要在if和else之间执行多条语句，必须用花括号把这些语句括起来成为一个块。</p>
<ul>
<li>
<p>介绍getchar()和putchar()<br>
getchar()函数不带任何参数，它从输入队列中返回下一个字符。例如，下面的语句读取下一个字符输入，并把该字符的值赋给变量ch：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">ch <span style="color:#f92672">=</span> getchar();
</code></pre></div><p>该语句与下面的语句效果相同：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">scanf(<span style="color:#e6db74">&#34;%c&#34;</span>,<span style="color:#f92672">&amp;</span>ch);
</code></pre></div><p>putchar函数打印它的参数。例如，下面的语句把之前赋给ch的值作为字符打印出来：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">putchar(ch);
</code></pre></div><p>该语句与下面的语句效果相同：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">printf(<span style="color:#e6db74">&#34;%c&#34;</span>,ch);
</code></pre></div><p>由于这些函数只处理字符，所以它们比更通用的scanf()和printf()函数更快、更简洁。而且，注意getchar()和putchar()不需要转换说明，因为它们只处理字符。这两个函数通常定义在stdio.h头文件中(而且，他们通常是预处理宏，而不是真正的函数，第16章会讨论类似函数的宏)。<br>
接下来，我们编写一个程序来说明这两个函数是如何工作的。该程序把一行输入重新打印出来，但是每个非空格都被替换成原字符在ASCII序列中的下一个字符，空格不变。这一过程可描述为&quot;如果字符是空白，原样打印；否则，打印原字符在ASCII序列中的下一个字符&rdquo;。<br>
<a href="../../c-example/cypher1.c">cypher1.c</a></p>
</li>
<li>
<p>ctype.h系列的字符函数<br>
C有一系列专门处理字符的函数，ctype.h头文件包含了这些函数的原型。这些函数接受一个字符作为参数，如果该字符属于某特殊的类别，就返回一个非零值；否则，返回0。例如，如果isalpha()函数的参数是一个字母，则返回一个非零值。如下：
<a href="../../c-example/cypher2.c">cypher2.c</a></p>
</li>
<li>
<p>多重选择else if<br>
现实生活中我们经常有多种选择。在程序中也可以用else if扩展if else结构模拟这种情况。</p>
</li>
<li>
<p>else与if配对<br>
如果程序中有许多if和else，编译器如何知道哪个if对应哪个else？<br>
规则是，如果没有花括号，else与离它最近的if匹配，除非最近的if被花括号括起来。</p>
</li>
<li>
<p>多层嵌套的if语句<br>
前面介绍的if&hellip;else if&hellip;else序列是嵌套if的一种形式，从一系列选项中选择一个执行。有时，选择一个特定选项后又引出其他选择，这种情况可以使用另一种嵌套if。例如，程序可以使用if else选择男女，if else的每个分支里又包含另一个if else来区分不同收入的群体。<br>
我们把这种形式的嵌套if应用在下面的程序中。给定一个整数，显示所有能整除它的约数。如果没有约数，则报告该数是一个素数。<br>
在编写程序的代码之前要规划好。首先，要总体设计一下程序。</p>
<ol>
<li>为方便起见，程序应该使用一个循环让用户能连续输入待测试的数。这样，测试一个新的数字时不必每次都要重新运行程序。</li>
<li>下一步，设计如何找出约数。最直接的方法是：</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">for</span>(div <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; div <span style="color:#f92672">&lt;</span> num; div<span style="color:#f92672">++</span>)
    <span style="color:#66d9ef">if</span>(num <span style="color:#f92672">%</span> div <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
        printf(<span style="color:#e6db74">&#34;%d is divisible by %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,num,div);
</code></pre></div><ol start="3">
<li>该循环检查2~num之间的所有数字，测试它们是否能被num整除。但是，这个方法有点浪费时间。可以改进一下，分析后发现，必须测试的书只要到num的平方根就可以了，不用到num。对于9这样的数字，不会节约很多时间，但是对于10000这样的数，使用哪一种方法求约数差别很大。不过，我们不用在程序中计算平方根，可以这样写测试条件：</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">for</span>(div <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; (div <span style="color:#f92672">*</span> div) <span style="color:#f92672">&lt;=</span> num;div<span style="color:#f92672">++</span>)
    <span style="color:#66d9ef">if</span>(num <span style="color:#f92672">%</span> div <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
        printf(<span style="color:#e6db74">&#34;%d is divisible by %d and %d.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,num,div,num<span style="color:#f92672">/</span>div);
</code></pre></div><p>不使用平方根而用这样的测试条件，有两个原因。其一，整数乘法比求平方根快。其二，我们还没有正式介绍平方根函数。<br>
4. 还有两个问题需要解决。第一个问题，如果待测试的数是一个完全平方数怎么办？报告144可以被12和12整除显得有点傻。可以使用嵌套if语句测试div是否等于num/div。如果是，程序只打印一个约数。第二个问题，如何知道一个数字是素数？如果num是素数，程序流不会进入if语句。要解决这个问题，可以在外层循环把一个变量设置为某个值，然后在if语句中把该变量重新设置为0.循环完成后，检查该变量是否是1，如果是，说明没有进入if语句，那么该数就是素数。这样的变量通常称为标记(flag)。<br>
<a href="../../c-example/divisors.c">divisors.c</a></p>
</li>
</ul>
<h4 id="逻辑运算符">逻辑运算符</h4>
<p>读者已经很熟悉了，if语句和while语句通常使用关系表达式作为测试条件。有时，把多个关系表达式组合起来会很有用。例如，要编写一个程序，计算输入的一行句子中除单引号和双引号以外其他字符的数量。这种情况下可以使用逻辑运算符，并使用句点(.)标识句子的末尾。<br>
<a href="../../c-example/chcount.c">chcount.c</a></p>
<ol>
<li>
<p>备选拼写：iso646.h头文件<br>
C是在美国用标准美式键盘开发的语言。但是在世界各地，并非所有的键盘都有和美式键盘一样的符号。因此，C99标准新增了可代替逻辑运算符的拼写，它们被定义在iso646.h头文件中。如果在程序中包含该头文件，便可用and代替&amp;&amp;、or代替||、not代替！。</p>
</li>
<li>
<p>优先级<br>
!运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相同，只比圆括号的优先级低。&amp;&amp;运算符的优先级比||运算符高，但是两者的优先级都比关系运算符低，比赋值运算符高。</p>
</li>
<li>
<p>求值顺序<br>
除了两个运算符共享一个运算对象的情况外，C通常不保证先对复杂表达式中哪部分求值。例如，下面的语句，可能先对表达式5 + 3求值，也可能先对表达式9 + 6求值：</p>
<blockquote>
<p>apples = (5+3) * (9+5)</p>
</blockquote>
<p>C把先计算哪部分的决定权留给编译器的设计者，以便针对特定系统优化设计。但是，对于逻辑运算符是个例外，C保证逻辑表达式的求值顺序是从左往右。&amp;&amp;和||运算符都是序列点，所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效。而且，C保证一旦发现某个元素让整个表达式无效，便立即停止求值。</p>
</li>
<li>
<p>范围<br>
&amp;&amp;运算符可用于测试范围。例如，要测试score是否在90~100的范围内，可以这样写：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">if</span>(range <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">90</span> <span style="color:#f92672">&amp;&amp;</span> range <span style="color:#f92672">&lt;=</span>  <span style="color:#ae81ff">100</span>)
    printf(<span style="color:#e6db74">&#34;Good show!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</code></pre></div><p>千万不要模仿数学上的写法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">if</span>(<span style="color:#ae81ff">90</span> <span style="color:#f92672">&lt;=</span> range <span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">100</span>)
    printf(<span style="color:#e6db74">&#34;Good show!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</code></pre></div><p>这样写的问题是代码有语义错误，而不是语法错误，所以编译器不会捕获这样的问题。由于&lt;=运算分手的求值顺序是从左往右，所以编译器把测试表达式解释为：<br>
(90 &lt;= range) &lt;= 100
子表达式90 &lt;= range的值要么是1，要么是0。这两个值都小于100，所以不管range的值是多少，整个表达式都恒为真。因此，在范围测试中要使用&amp;&amp;。<br>
许多代码都用范围测试来确定一个字符是否小写字母。例如，假设ch是char类型的变量：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">if</span>(ch <span style="color:#f92672">&gt;=</span> <span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">&amp;&amp;</span>ch <span style="color:#f92672">&lt;=</span> <span style="color:#e6db74">&#39;z&#39;</span>)
    printf(<span style="color:#e6db74">&#34;That&#39;s a lowercase character.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</code></pre></div><p>该方法仅对于像ASCII这样的字符编码有效，这些编码中相邻字母与相邻数字一一对应。但是，对于像EBCDIC这样的代码就没有了。相应的可移植方法是，用ctype.h系列中的islower()函数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">if</span>(islower(ch))
    printf(<span style="color:#e6db74">&#34;That&#39;s a lowercase character.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</code></pre></div><p>无论使用哪种特定的字符编码，islower()函数都能正常运行。</p>
</li>
</ol>
<h4 id="一个统计单词的程序">一个统计单词的程序</h4>
<p>现在，我们可以编写一个统计单词数量的程序(即，该程序读取并报告单词的数量)。该程序还可以计算字符数和行数。先来看看编写这样的程序要涉及那些内容。<br>
首先，该程序要逐个字符读取输入，知道何时停止读取。然后，该程序能识别并计算这些内容：字符、行数和单词。<br>
<a href="../../c-example/wordcnt.c">wordcnt.c</a></p>
<h4 id="条件运算符--">条件运算符： ？ ：</h4>
<p>C提供条件表达式(conditional expression)作为表达式if else语句的一种便捷方式 ，该 表达式使用? :条件运算符。该运算符分为两部分，需要3个运算对象。<br>
条件表达式的通用形式如下：</p>
<blockquote>
<p>expression1 ? expression2 : expression3</p>
</blockquote>
<h4 id="循环辅助continue和break">循环辅助:continue和break</h4>
<p>一般而言，程序进入循环后，在下一次循环测试之前会执行完循环体中的所有语句。continue和break语句可以根据循环体中的测试结果来忽略一部分循环内容，甚至结束循环。</p>
<ol>
<li>continue语句<br>
3种循环都可以使用continue语句。执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环。<br>
从何处开始继续循环？对于while和do while循环，执行continue语句后的下一个行为是对循环的测试表达式求值。对于for循环，执行continue后的下一个行为是对更新表达式求值，然后是对循环测试表达式求值。</li>
<li>break语句<br>
程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段。<br>
break还可用于因其他原因退出循环的情况。<br>
在for循环中的break和continue的情况不同，执行完break语句后会直接执行循环后面的第1条语句，连更新部分也跳过。嵌套循环内层的break只会让程序跳出包含它的当前循环，要跳出外层循环还需要一个break；</li>
</ol>
<h4 id="多重选择switch和breaak">多重选择：switch和breaak</h4>
<p>使用条件运算符和if else语句很容易编写二选一的程序。然而，有时程序需要在多个选项中进行选择。可以用if else if&hellip;else来完成。但是，大多数情况下使用switch语句更方便。</p>
<ol>
<li>
<p>switch语句<br>
要对紧跟在关键字switch后圆括号中的表达式求值。然后程序扫描标签列表，直到发现一个匹配的值为止。然后程序跳转至那一行。如果没有匹配的标签怎么办？如果有default:标签行，就跳转至该行；否则程序继续执行在switch后面的语句。<br>
break语句在其中起什么作用？它让程序离开switch语句，跳至switch语句后面的下一条语句。如果没有break语句，就会从匹配标签开始执行到switch末尾。<br>
switch在圆括号中的测试表达式的值应该是一个整数值(包括char类型)。case标签必须是整数类型的常量或整型常量表达式。不能用变量作为case标签。</p>
</li>
<li>
<p>只读每行的首字符<br>
这种丢弃一行中其他字符的行为，经常出现在响应单字符的交互程序中。可以用下面的代码实现这样的行为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">while</span>(getchar()<span style="color:#f92672">!=</span><span style="color:#e6db74">&#39;\n&#39;</span>)
    <span style="color:#66d9ef">continue</span>;
</code></pre></div><p>循环从输入中读取字符，包含按下Enter键产生的换行符。注意，函数的返回值并没有赋给ch，以上代码所做的只是读取并丢弃字符。由于最后丢弃的字符是换行符，所所以下一个被读取的字符是下一行的首字母。在外层的while循环中，getchar()读取首字母并赋给ch。</p>
</li>
<li>
<p>多重标签<br>
如下程序所示，可以在switch语句中使用多重case标签。<br>
<a href="../../c-example/vowels.c">vowels.c</a></p>
</li>
<li>
<p>switch和if else<br>
何时使用switch？何时使用if else？你经常会别无选择。如果根据浮点类型的变量或表达式来选择，就无法使用switch。如果根据变量在某范围内决定程序流的去向，使用switch就很麻烦，这种情况使用if就很方便。</p>
</li>
</ol>
<h4 id="goto语句">goto语句</h4>
<p>早期版本的BASIC和FORTRAN所依赖的goto语句，在C中仍然可用。但是C和其他两种语言不同，没有goto语句C程序也能运行良好。<br>
goto语句有两部分：goto和标签名。标签的命令遵循变量命名规则，如下所示：</p>
<blockquote>
<p>goto part2;</p>
</blockquote>
<p>要让这条语句正常工作，函数还必须包含另一条标为part2的语句，该语句一标签名后紧跟一个冒号开始：</p>
<blockquote>
<p>part2:printf(&ldquo;Refined analysis:\n&rdquo;);</p>
</blockquote>
<ol>
<li>避免使用goto<br>
原则上，根本不用在C程序中使用goto语句。但是，如果你曾经学过FORTRAN或BASIC，可能还会依赖用goto来编程。<br>
但是C程序员可以接受一种goto的用法，出现问题时从一组嵌套循环中跳出(一条break语句只能跳出当前循环)</li>
</ol>
<h3 id="字符输入输出和输入验证">字符输入/输出和输入验证</h3>
<p>本章介绍以下内容：<br>
更详细地介绍输入、输出以及缓冲输入和无缓冲输入的区别<br>
如何通过键盘模拟文件结尾条件<br>
如何使用重定向把程序和文件相连接<br>
创建更友好的用户界面</p>
<h4 id="单字符iogetchar和puchar">单字符I/O：getchar()和puchar</h4>
<p>之前提到过，getchar()和puchar()每次只处理一个字符。你可能认为这种方法实在太笨拙了，毕竟与我们的阅读方式相差甚远。但是，这种方法很适合计算机。而且，这是绝大多数文本(即，普通文字)处理程序所用的核心方法。如下程序，获取从键盘输入的字符，并把这些字符发送到屏幕上。程序使用while循环，当读到#字符时停止。<br>
<a href="../../c-example/echo.c">echo.c</a><br>
为何输入的字符能直接显示在屏幕上？如果用一个特殊字符(如，#)来结束输入，就无法在文本中使用这个字符，是否有更好的方法结束输入？要回答这些问题，首先要了解C程序如何处理键盘输入，尤其是缓冲和标准输入文件的概念。</p>
<h4 id="缓冲区">缓冲区</h4>
<p>如果在老式系统运行程序echo.c，你输入文本时可能显示如下：</p>
<blockquote>
<p>HHeelllloo,,tthheerree..II wwoouulldd[enter]
lliikkee aa#</p>
</blockquote>
<p>以上行为是个例外。像这样回显用户输入的字符后立即重复打印该字符是属于无缓冲(或直接)输入，即正在等待的程序可立即使用输入的字符。对于该例，大部分系统在用户按下Enter键之前不会重复打印刚输入的字符，这种输入形式属于缓冲输入。用户输入的字符被收集并存储在一个被称为缓冲区(buffer)的临时存储区，按下Enter键后，程序才可使用用户输入的字符。两种输入的对比如下：
<img src="../../images/C-Learning/%E7%BC%93%E5%86%B2%E8%BE%93%E5%85%A5%E5%92%8C%E6%97%A0%E7%BC%93%E5%86%B2%E8%BE%93%E5%85%A5.png" alt="缓冲输入和无缓冲输入.png"><br>
为什么要有缓冲区？</p>
<ul>
<li>把若干字符作为一个块进行传输比逐个发送这些字符节约时间。</li>
<li>如果用户打错字符，可以直接通过键盘修正错误。</li>
</ul>
<p>虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入。例如，在游戏中，你希望按下一个键就执行相应的指令。因此，缓冲输入和无缓冲输入都有用武之地。<br>
缓冲分为两类：完全缓冲I/O和行缓冲I/O。完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区(内容被发送至目的地)，通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是512字节和4096字节。行缓冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。<br>
那么，使用缓冲输入还是无缓冲输入？ANSI C和后续的C标准都规定输入时缓冲的，不过最初K&amp;R把这个决定权交给了编译器的编写者。<br>
ANSI C决定把缓冲输入作为标准的原因是：一些计算机不允许无缓冲输入。如果你的计算机允许无缓冲输入，那么你所用的C编译器很可能会提供一个无缓冲输入的选项。例如，许多IBM PC兼容机的编译器都为支持无缓冲输入提供一系列特殊的函数，其原型都在conio.h头文件中。这些函数包括用于回显无缓冲输入的getche()函数和用于无回显无缓冲输入的getch()函数。UNIX系统使用另一种不同的方式控制缓冲。在UNIX系统中，可以使用ioctl()函数指定待输入的类型，然后用getchar()执行相应的操作。在ANSI C中，用setbuf()和setvbuf()函数控制缓冲，但是受限于一些系统的内部设置，这些函数可能不起作用。总之，ANSI没有提供调用无缓冲输入的标准方式，这意味着是否能进行无缓冲输入取决于计算机系统。</p>
<h4 id="结束键盘输入">结束键盘输入</h4>
<p>在echo.c程序中，只要输入的字符中不含#，那么程序在读到#时才会结束。但是，#也是一个普通的字符，有时不可避免要用到。应该用一个在文本中用不到的字符来标记输入完成，这样的字符不会无意间出现在输入中，在你不希望结束程序的时候终止程序。C的确提供了这样的字符，不过在此之前，先来了解一下C处理文件的方式。</p>
<ol>
<li>文件、流和键盘输入<br>
文件(file)是存储器中存储信息的区域。通常，文件都保存在某种永久存储器中(如，硬盘、U盘或DVD等)。毫无疑问，文件对于计算机系统相当重要。例如，你编写的C程序就保存在文件中，用来编译C程序的程序也保存在文件中。后者说明，某些程序需要访问指定的文件。当编译存储在名为echo.c文件中的程序时，编译器打开echo.c文件并读取其中的内容。当编译器处理完后，会关闭该文件。其他程序，例如文字处理器，不仅要打开、读取和关闭文件，还要把数据写入文件。<br>
C是一门强大、灵活的语言，有许多用于打开、读取、写入和关闭文件的库函数。从较低层面上，C可以使用主机操作系统的基本文件工具直接处理文件，这些直接调用操作系统的函数被称为底层I/O(low-level I/O)。由于计算机系统各不相同，所以不可能为普通的底层I/O函数创建标准库，ANSI C也不打算这样做。然而从较高层面上，C还可以通过标准I/O包(standard I/O package)来处理文件。这涉及创建用于处理文件的标准模型和一套标准I/O函数。在这一层面上，具体的C实现负责处理不同系统的差异，以便用户使用统一的界面。<br>
上面讨论的差异指的是什么？例如，不同的系统储存文件的方式不同。有些系统把文件的内容存储在一处，而文件相关的信息存储在另一处；有些系统在文件中创建一份文件描述。在处理文件方面，有些系统使用单个换行符标记行末尾，而其他系统可能使用回车符和换行符的组合来表示行末尾。有些系统用最小字节来衡量文件的大小，有些系统则以字节块的大小来衡量。<br>
如果使用标准I/O包，就不用考虑这些差异。因此，可以用if(ch == &lsquo;\n&rsquo;)检查换行符。即使系统实际用的是回车符和换行符的组合来标记行末尾，I/O函数会在两种表示法之间相互转换。<br>
从概念上看，C程序处理的是流而不是直接处理文件。流(steam)是一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。<br>
本章着重理解C把输入和输出设备视为存储设备上的普通文件，尤其是把键盘和显示设备视为每个C程序自动打开的文件。stdin流表示键盘输入，stdout流表示屏幕输出。getchar()、putchar()、printf()和scanf()函数不堵车标准I/O包的成员，处理这两个流。</li>
<li>文件结尾<br>
计算机操作系统要以某种方式判断文件的开始和结束。检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾。CP/M、IBM-DOS和MS-DOS的文本文件曾经使用过这种方法。如今，这些操作系统可以使用内嵌的Ctrl+Z字符来标记文件结尾。这曾经是操作系统使用的唯一标记，不过现在有一些其他的选择，例如记录文件的大小。所有现代的文本文件不一定有嵌入的Ctrl+Z,但是如果有，该操作系统会将其视为一个文件结尾标记。<br>
操作系统使用的另一种方法是存储文件大小的信息。如果文件有3000字节，程序在读到3000字节时便达到文件的末尾。MS-DOS及其相关系统使用这种方法处理二进制文件，因为用这种方法可以在文件中存储所有的字符包括Ctrl+Z。新版的DOS也使用这种方法处理文本文件。UNIX使用这种方法处理所有的文件。<br>
无论操作系统实际使用何种方法检测文件结尾，在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值，即EOF(end of file的缩写)。scanf()函数检测到文件结尾时也返回EOF。通常，EOF定义在stdio.h文件中。<br>
如何在程序中使用EOF？把getchar()的返回值和EOF作比较。如果两值不同，就说明没有达文件结尾。也就是说，可以使用下面这样的表达式:</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">while</span>((ch <span style="color:#f92672">=</span> getchar())<span style="color:#f92672">!=</span>EOF)
</code></pre></div><p>如果正在读取的是键盘输入不是文件会怎样？绝大部分系统都有办法通过键盘模拟文件结尾条件。了解这些以后，读者可以重写程序清单8.1的程序。<br>
<a href="../../c-example/echo_eof.c">echo_eof.c</a><br>
既然echo_eof.c程序能把用户输入的内容拷贝到屏幕上，那么考虑一下该程序还可以做什么。假设以某种方式把一个文件传送给它，然后它把文件中的内容打印在屏幕上，当到达文件结尾发现EOF信号时停止。或者，假设以某种方式把程序的输出定向到一个文件，然后通过键盘输入数据，用echo_eof.c来储存文件中输入的内容。假设同时使用这两种方法：把输入从一个文件定向到echo_eof.c中，并把输出发送至另一个文件，然后便可以使用echo_eof.c来拷贝文件。关键是要控制输入流和输出流，这是我们下一个要讨论的主题。</p>
<h4 id="重定向和文件">重定向和文件</h4>
<p>输入和输出涉及函数、数据和设备。例如，考虑echo_eof.c，该程序使用输入函数getchar()。输入设备是键盘，输入数据流由字符组成。假设你希望输入函数和数据类型不变，仅改变程序查找数据的位置。那么，程序如何知道去哪里查找输入。<br>
在默认情况下，C程序使用标准I/O包查找标准输入作为输入源。这就是前面介绍过的stdin流，它是把数据读入计算机的常用方式。它可以是一个过时的设备，如磁带、穿孔卡或电传打印机，或者是键盘，甚至是一些先进技术，如语音输入。然而，现代计算机非常灵活，可以让它到别处查找输入。尤其是，可以让一个程序从文件中查找输入，而不是从键盘。<br>
程序可以通过两种方式使用文件。第1种方法是，显式使用特定的函数打开文件、关闭文件、读取文件、写入文件，诸如此类。在后续章节再详细介绍这种方法。第2种方法是，设计能与键盘和屏幕互动的程序，通过不同的渠道重定向输入至文件和从文件输出。换言之，把stdin流重新赋给文件。继续使用getchar()函数从输入流中获取数据，但它不关心从流的什么位置获取数据。虽然这种重定向的方法在某些方面有些限制，但是用起来比较简单，而且能让读者熟悉普通的文件处理技术。<br>
重定向的一个主要问题与操作系统有关，与C无关。尽管如此，许多C环境中(包括UNIX、Linux和Windows命令提示模式)都有重定向特性，而且一些C实现还在某些缺乏重定向特性的系统中模拟它。在UNIX上运行苹果OS X，可以用UNIX命令行模式启动Terminal应用程序。接下来介绍UNIX、Linux和Windows的重定向。<br>
UNIX(运行命令行模式时)、Linux(ditto)和Window命令行提示都能重定向输入、输出。重定向输入让程序使用文件而不是键盘输入，重定向输出让程序输出至文件而不是屏幕。</p>
<ol>
<li>
<p>重定向输入<br>
假设已经编译了echo_eof.c程序，并把可执行版本放入一个名为echo_eof的文件中。运行该程序，输入可执行文件名：echo_eof<br>
该程序的运行情况和前面描述的一样，获取用户从键盘输入的输入。现在，假设你要用该程序处理名为words的文本文件。文本文件(text file)时内含文本的文件，其中储存的数据是我们可识别的字符。文件的内容可以是一篇散文或者C程序。内涵机器语言指令的文件(如存储可执行程序的文件)不是文本文件。由于该程序的操作对象是字符，所以要使用文本文件。<br>
只需用下面的命令代替上面的命令即可：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">echo_eof&lt;words  
</code></pre></div><p>&lt;符号是UNIX和DOS/Windows的重定向运算符。该运算符使words文件与stdin流相关联，把文件中的内容导入echo_eof程序。echo_eof程序本身并不知道输入的内容是来自文件还是键盘就，它只知道这是需要导入的字符流，所以它读取这些内容并把字符逐个打印在屏幕上，直至读到文件结尾。因为C把文件和I/O设备放在一个层面，所以文件就是现在的I/O设备放在一个层面，所以文件就是现在的I/O设备。</p>
</li>
<li>
<p>重定向输出<br>
现在假设要用echo_eof把键盘输入的内容发送到名为mywords的文件中。然后，输入以下命令并开始输入：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">echo_eof &gt; mywords  
</code></pre></div><p>/&gt;符号是第2个重定向运算符。它创建了一个名为mywords的新文件，然后把echo_eof的输出重定向至该文件中。重定向把stdout从显示设备(显示器)赋给mywords文件。如果已经有一个名为mywords的文件，通常会擦除该文件的内容，然后替换新的内容。所有出现在屏幕的字母都是你刚才输入的，其副本存储在文件中。在下一行的开始处按下Ctrl+D或Ctrl+Z即可结束该程序。</p>
</li>
<li>
<p>组合重定向<br>
现在，假设你希望制作一份mywords文件的副本，并命名为savewords。只需输入以下命令即可：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">echo_eof &lt; mywords &gt; savewords  
</code></pre></div><p>下面的命令也起作用，因为命令与重定向运算符的顺序无关：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">echo_eof &gt; savewords &lt; mywords  
</code></pre></div><p>在UNIX、Linux或Windows/DOS系统中使用两个重定向运算符(&lt; 和 &gt;)时，要遵循以下原则</p>
<ul>
<li>重定向运算符连接一个可执行程序和一个数据文件</li>
<li>使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个文件</li>
<li>文件名和运算符之间的空格不是必须的</li>
</ul>
<p>UNIX、Linux或Windows/DOS还有&raquo;运算符，该运算符可以把数据添加到现有文件的末尾，而|运算符能把一个文件的输出连接到另一个文件的输入。</p>
</li>
</ol>
<h4 id="创建更友好的用户界面">创建更友好的用户界面</h4>
<ol>
<li>
<p>使用缓冲输入<br>
缓冲输入用起来比较方便，因为在把输入发送给程序之前，用户可以编辑输入。但是，在使用输入的字符时，它也会给程序员带来麻烦。前面实例中看到的问题是，缓冲输入要求用户按下Enter键发送输入。这一动作也传送了换行符，程序必须妥善处理这个麻烦的换行符。我们以一个猜谜程序为例。用户选择一个数字，程序猜用户选中的数字是多少。该程序使用的方法单调乏味，先不要在意算法，我们关注的重点在输入和输出。如下：<br>
<a href="../../c-example/guess.c">guess.c</a><br>
注意，每次输入n时，程序打印了两条消息。这是由于程序读取n作为用户否定了数字1，然后还读取了一个换行符作为用户否定了数字2。<br>
一种解决方案是，使用while循环丢弃输入行最后剩余的内容，包括换行符。这种方法的优点是，能把no和no way这样的响应视为简单的n。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">while</span>(getchar()<span style="color:#f92672">!=</span><span style="color:#e6db74">&#39;y&#39;</span>)
{
    printf(<span style="color:#e6db74">&#34;Well, then, is is %d?</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">++</span>guess);
    <span style="color:#66d9ef">while</span>(getchar() <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\n&#39;</span>)
        <span style="color:#66d9ef">continue</span>;
}
</code></pre></div><p>这的确是解决了换行符的问题。但是，该程序还是会把f视为n。我们用if语句筛选其他响应。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">char</span> response;
<span style="color:#66d9ef">while</span>((response <span style="color:#f92672">=</span> getchar()) <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;y&#39;</span>)
{
    <span style="color:#66d9ef">if</span>(response <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;n&#39;</span>)
        printf(<span style="color:#e6db74">&#34;Well, then, is it %d?</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">++</span>guess);
    <span style="color:#66d9ef">else</span>
        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Sorry, I understand only y or n.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">while</span>(getchar() <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\n&#39;</span>)
        <span style="color:#66d9ef">continue</span>;
}
</code></pre></div></li>
<li>
<p>混合数值和字符输入<br>
假设程序要求用getchar()处理字符输入，用scanf()处理数值输入，这两个函数都能很好地完成任务，但是不能把它们混用。因为getchar()读取每个字符，包括空格、制表符和换行符；而scanf()在读取数字时则会跳过空格、制表符和换行符。<br>
<a href="../../c-example/showchar1.c">showchar1.c</a><br>
while循环实现了丢弃scanf()输入后面所有字符(包括换行符)的功能，为循环的下一轮读取做好了准备。</p>
</li>
</ol>
<h4 id="输入验证">输入验证</h4>
<pre><code>在实际应用中，用户不一定会按照程序的指令行事。用户的输入和程序期望的输入不匹配时常发生，这会导致程序运行失败。作为程序员，除了完成编程的本职工作，还要事先预料一些可能的输入错误，这样才能编写出能检测并处理这些问题的程序。  
假如，你编写了一个处理非负数整数的循环，但是用户很可能输入一个负数。你可以使用关系表达式来排除这种情况：  

``` C 
long n;
scanf(&quot;%ld&quot;,&amp;n);
while(n &gt;= 0)
{
    //处理n  
    scanf(&quot;%ld&quot;,&amp;n);//获取下一个值
}
```

另一类潜在的陷阱是，用户可能输入错误类型的值，如字符q。排除这种情况的一种方法是，检查scanf()的返回值。scanf()返回成功读取项的个数。因此，改进如下：  

``` C 
long n;
while(scanf(&quot;%ld&quot;,&amp;n) == 1 &amp;&amp; n &gt;= 0)
{
    //处理n
}
```

while循环条件可以描述为“当输入是一个整数且该整数为正时”。  
对于最后的例子，当用户输入错误类型的值是，程序结束。然而，也可以让程序友好些，提示用户再次输入正确类型的值。在这种情况下，要处理有问题的输入。如果scanf()没有成功读取，就会将其留在输入队列中。这里要明确，输入实际上是字符流。可以使用getchar()函数逐字符地读取输入，甚至可以把这些想法结合在一个函数中，如下：  

``` C
long get_long(void)
{
    long input;
    char ch;
    while(scanf(&quot;%ld&quot;,&amp;input) != 1)
    {
        while((ch = getchar()) != '\n')
            putchar(ch);
        printf(&quot; is not an integer.\nPlease enter an&quot;);            printf(&quot;integer value,such as 25,-178,or 3:&quot;);
    }
    return input;
}
```

该函数要把一个int类型的值读取变量input中。如果读取失败，函数则进入外层循环体。然后内层循环逐字符地读取错误的输入。注意，该函数丢弃该输入行的所有剩余内容。还有一个方法是，只丢弃下一个字符或单词，然后该函数提示用户再次输入。外层循环重复运行，直到用户成功输入整数，此时scanf()的返回值为1。  

在用户输入整数后，程序可以检查该值是否有效。考虑一个例子，要求用户输入一个上限和一个下限来定义值的范围。在该例中，你可能希望程序检查第1个值是否大于第2个值，除此之外还要检查这些值是否在允许的范围内。如下：  

``` C
bool bad_limits(long begin, long end, long low, long high)
{
    bool not_good = false;
    if(begin &gt; end)
    {
        printf(&quot;%ld isn't smaller than %ld.\n&quot;,begin, end);
        not_good = true;
    }
    if(begin &lt; low || end &lt; low)
    {
        printf(&quot;Values must be %ld or greater.\n&quot;,low);
        not_good = true;
    }
    if(begin &gt; high || end &gt; high)
    {
        printf(&quot;Values must be %ld or less.\n&quot;,high);
        not_good = true;
    }
    return not_good;
}
```

下列函数使用了上述两个函数为一个进行算术运算的函数提供整数，该函数计算特定范围内所有整数的平方和。程序限制了范围的上限是10000000，下限是-10000000。  
[checking.c](../../c-example/checking.c)  
</code></pre>
<ol>
<li>
<p>分析程序<br>
虽然checking.c核心的计算部分(sum_squares())很短，但是输入验证部分比以往程序实例要复杂。接下来分析其中的一些要素，先着重讨论程序的整体结构。<br>
程序遵循模块化的编程思想，使用独立函数(模块)来验证输入和管理显示。程序越大，使用模块化编程就越重要。<br>
main()函数管理程序流，为其他函数委派任务。它使用get_long()获取值、while循环处理值、badlimits()函数检查值是否有效、sum_squres()函数处理实际的计算。</p>
</li>
<li>
<p>输入流和数字<br>
在编写处理错误输入的代码时，应该很清楚C是如何处理输入的。考虑下面的输入：</p>
</li>
</ol>
<blockquote>
<p>is 28 12.4</p>
</blockquote>
<p>在我们眼中，这就像是一个由字符、整数和浮点数组成的字符串。但是对C程序而言，这是一个字节流。第1个字节是字母i的字符编码，第2个字节是字母s的字符编码、第3个字节是空格字符的字符编码，第4个字节是数字2的字符编码，等等。所以，如果get_long()函数处理这一行输入，第1个字符是非数字，那么整行输入都会被丢弃，包括其中的数字，因为这些数字只是该输入行中的其他字符。<br>
虽然输入流由字符组成，但是也可以设置scanf()函数把它们转换成数值。例如 42。<br>
如果在scanf()函数中使用%c转换说明，它只会读取字符4并将其存储在char类型的变量中。如果使用%s转换说明，他会读取字符4和字符2这两个字符，并将其存储在字符数组中。如果使用%d转换说明，scanf()同样会读取两个字符，但是随后会计算出它们对应的整数值：4*10+2,即42，然后将表示该整数的二进制数储存在int类型的变量中。如果使用%f转换说明，scanf()也会读取两个字符，计算出它们对应的数值42.0，用内部的浮点表示法表示该值，并将结果储存在float类型的变量中。<br>
简而言之，输入由字符组成，但是scanf()可以把输入转换成整数值或浮点数值。使用转换说明(如%d或%f)限制了可接受输入的字符类型，而getchar()和使用%c的scanf()接受所有的字符。</p>
<h4 id="菜单浏览">菜单浏览</h4>
<p>许多计算机程序都把菜单作为用户界面的一部分。菜单给用户提供方便的同时，却给程序员带来了一些麻烦。我们看看其中涉及了哪些问题。<br>
菜单给用户提供了一份响应程序的选项。假设有下面一个例子：</p>
<blockquote>
<p>Enter the letter of your choice:<br>
a. advice   b. bell<br>
c. count    q. quit</p>
</blockquote>
<p>理想状态是，用户输入程序所列选项之一，然后程序根据用户所选项完成任务。作为一名程序员，自然希望这一过程能顺利进行。因此，第1个目标是：当用户遵循指令时程序顺利运行；第2个目标是：当用户没有遵循指令时，程序也能顺利运行。显而易见，要实现第2个目标难度较大，因为很难预料用户在使用程序时的所有错误情况。<br>
现在的应用程序通常使用图形界面，可以点击按钮、查看对话框、触摸图标，而不是我们实例中的命令行模式。但是，两者的处理过程大致相同：给用户提供选项、检查并执行用户的响应、保护程序不受误操作的影响。除了界面不同，它们底层的程序结构也几乎相同。但是，使用图形界面更容易通过限制选项控制输入。</p>
<ol>
<li>
<p>任务<br>
我们来更具体地分析一个菜单程序需要执行哪些任务。它要获取用户的响应，根据响应选择要执行的动作。另外，程序应该提供返回菜单的选项。C的switch语句是根据选项决定行为的好工具，用户的每个选择都可以对应一个特定的case标签。使用while语句可以实现重复访问菜单的功能。</p>
</li>
<li>
<p>使执行更顺利<br>
当你决定实现这个程序时，就要开始考虑如何让程序顺利运行。例如，你能做的是让“获取选项”部分的代码筛选掉不合适的响应，只把正确的响应传入switch。这表明需要为输入过程提供一个只返回正确响应的函数。结合while循环和switch语句，其程序结构如下:</p>
</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> <span style="color:#a6e22e">get_choice</span>(<span style="color:#66d9ef">void</span>);
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">count</span>(<span style="color:#66d9ef">void</span>);
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">int</span> choice;
    <span style="color:#66d9ef">while</span>((choice <span style="color:#f92672">=</span> get_choice()) <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;q&#39;</span>)
    {
        <span style="color:#66d9ef">switch</span>(choice)
        {
            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">:</span>
                printf(<span style="color:#e6db74">&#34;Buy low,sell high.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
                <span style="color:#66d9ef">break</span>;
            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;b&#39;</span><span style="color:#f92672">:</span>
                putchar(<span style="color:#e6db74">&#39;\a&#39;</span>);
                <span style="color:#66d9ef">break</span>;
            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;c&#39;</span><span style="color:#f92672">:</span>
                count();
                <span style="color:#66d9ef">break</span>;
            <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
                printf(<span style="color:#e6db74">&#34;Program error!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
                <span style="color:#66d9ef">break</span>;
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>定义get_choice()函数只能返回&rsquo;a&rsquo;、&lsquo;b&rsquo;、&lsquo;c&rsquo;和&rsquo;q&rsquo;。get_choice()的用法和getchar()相同，两个函数都是获取一个值，并与终止值(该例子中是&rsquo;q&rsquo;)作比较。我们尽量简化实际的菜单选项，以便读者把注意力集中在程序结构上。稍后再讨论count()函数。default语句可以方便调试。如果get_choice()函数没能把返回值限制为菜单指定的几个选项值，default语句有助于发现问题所在。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">char</span> <span style="color:#a6e22e">get_choice</span>(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">int</span> ch;
    pirntf(<span style="color:#e6db74">&#34;Enter the letter of your choice:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    printf(<span style="color:#e6db74">&#34;a. advice        b. bell</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    printf(<span style="color:#e6db74">&#34;c. count         q. quit</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    ch <span style="color:#f92672">=</span> getchar();
    <span style="color:#66d9ef">while</span>((ch <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#f92672">||</span> ch <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#39;c&#39;</span>) <span style="color:#f92672">&amp;&amp;</span> ch <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;q&#39;</span>)
    {
        printf(<span style="color:#e6db74">&#34;Please respond with a, b, c, or q.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        ch <span style="color:#f92672">=</span> getchar();
    }
    <span style="color:#66d9ef">return</span> ch;
}
</code></pre></div><p>缓冲输入依旧带来些麻烦，程序把用户每次按下Return键产生的换行符视为错误响应。为了让程序的界面更流畅，该函数应该跳过这些换行符。<br>
这类问题有多种解决方案。一种是用名为get_first()的新函数替换getchar()函数，读取一行的第一个字符并丢弃剩余的字符。这种方法的有点是，把类型act这样的输入视为简单的a，而不是继续吧act中的c作为选项c的一个有效的响应。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">char</span> <span style="color:#a6e22e">get_choice</span>(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">int</span> ch;
    printf(<span style="color:#e6db74">&#34;Enter the letter of your choice:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    printf(<span style="color:#e6db74">&#34;a. advice        b. bell</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    printf(<span style="color:#e6db74">&#34;c. count         q. quit</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    ch <span style="color:#f92672">=</span> get_first();
    <span style="color:#66d9ef">while</span>((ch <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#f92672">||</span> ch <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#39;c&#39;</span>) <span style="color:#f92672">&amp;&amp;</span> ch <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;q&#39;</span>)
    {
        printf(<span style="color:#e6db74">&#34;Please respond with a, b, c, or q.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        ch <span style="color:#f92672">=</span> get_first();
    }
    <span style="color:#66d9ef">return</span> ch;
}

<span style="color:#66d9ef">char</span> <span style="color:#a6e22e">get_first</span>()
{
    <span style="color:#66d9ef">int</span> ch;
    ch <span style="color:#f92672">=</span> getchar();
    <span style="color:#66d9ef">while</span>(getchar() <span style="color:#960050;background-color:#1e0010">！</span><span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\n&#39;</span>)
        <span style="color:#66d9ef">continue</span>;
    <span style="color:#66d9ef">return</span> ch;
}
</code></pre></div><ol start="3">
<li>混合字符和数值输入<br>
前面分析过混合字符和数值输入会产生一些问题，创建菜单也有这样的问题。例如，假设count()函数的代码如下：</li>
</ol>
<pre><code>void count(void)
{
    int n,i;  
    printf(&quot;Count how far? Enter an integer:\n&quot;);
    scanf(&quot;%d&quot;,&amp;n);
    for(i = 1; i &lt;= n; i++)
        printf(&quot;%d\n&quot;,i);
}
</code></pre><p>如果输入3作为响应，scanf()会读取3并把换行符留在输入队列中。下次调用get_choice()将导致get_first()返回这个换行符，从而导致我们不希望出现的行为。<br>
重写get_first()，使其返回下一个非空白字符而不仅仅是下一个字符，即可修复这个问题。另一种方法是，在count()函数中清理换行符，如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">count</span>(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">int</span> n, i;
    printf(<span style="color:#e6db74">&#34;Count how far? Enter an integer:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    n <span style="color:#f92672">=</span> get_int();
    <span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i);
    <span style="color:#66d9ef">while</span>(getchar() <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\n&#39;</span>)
        <span style="color:#66d9ef">continue</span>;
}
</code></pre></div><p>最后的菜单程序如下：<br>
<a href="../../c-example/menutte.c">menuette.c</a></p></div>
        <div class="post-footer">
            <div class="info">
                <span class="separator"><a class="category" href="/guowei/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></span>

                <span class="separator"><a class="tag" href="/guowei/tags/c/">C</a></span>

            </div>
        </div>

        
    </div>


        </div>
    </div>
</div>

<script type="text/javascript"
        src="http://guowei7.gitee.io/guowei/js/jquery.min.86b1e8f819ee2d9099a783e50b49dff24282545fc40773861f9126b921532e4c.js"
        integrity="sha256-hrHo&#43;BnuLZCZp4PlC0nf8kKCVF/EB3OGH5EmuSFTLkw="
        crossorigin="anonymous"></script>




<script type="text/javascript"
        src="http://guowei7.gitee.io/guowei/js/bundle.min.0f9c74cb78f13d1f15f33daff4037c70354f98acfbb97a6f61708966675c3cae.js"
        integrity="sha256-D5x0y3jxPR8V8z2v9AN8cDVPmKz7uXpvYXCJZmdcPK4="
        crossorigin="anonymous"></script>

<script type="text/javascript"
        src="http://guowei7.gitee.io/guowei/js/medium-zoom.min.92f21c856129f84aeb719459b3e6ac621a3032fd7b180a18c04e1d12083f8aba.js"
        integrity="sha256-kvIchWEp&#43;ErrcZRZs&#43;asYhowMv17GAoYwE4dEgg/iro="
        crossorigin="anonymous"></script>
</body>

</html>
